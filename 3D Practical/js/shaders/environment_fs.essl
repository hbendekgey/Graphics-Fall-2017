Shader.source[document.currentScript.src.split('js/shaders/')[1]] = `
	precision highp float;

	// for applying the texture coloring
	varying vec3 rayDir;
	uniform sampler2D probeTexture;

	uniform vec3 cameraPos;

	uniform vec4 lightPos[1];
	uniform vec3 lightPowerDensity[1];
	uniform vec3 spotMainDir[1];
	uniform mat4 quadrics[6];


	float intersectClippedQuadric(mat4 A, mat4 B, vec4 e, vec4 d) {
		float a = dot(d * A, d);
		float b = dot(d * A, e) + dot(e * A, d);
		float c = dot(e * A, e);
		float discriminant = pow(b, 2.0) - 4.0 * a * c;
		if (discriminant < 0.0) {
			return -1.0;
		}
		float t1 = ((-1.0 * b) + sqrt(discriminant)) / (2.0 * a);
		float t2 = ((-1.0 * b) - sqrt(discriminant)) / (2.0 * a);

		vec4 r1 =  e + (d * t1);
		vec4 r2 =  e + (d * t2);

		bool t1Valid = t1 >= 0.0 && dot(r1 * B, r1) <= 0.0;
		bool t2Valid = t2 >= 0.0 && dot(r2 * B, r2) <= 0.0;
		if (!t1Valid && !t2Valid) {
			return -1.0;
		} else if (!t1Valid) {
			return t2;
		} else if (!t2Valid) {
			return t1;
		} else {
			return min(t1, t2);
		}
	}

	vec4 shadeEnvironment() {
		vec3 mirrorSphereCoord = normalize(vec3(0.0,0.0,1.0) + rayDir) / 2.0;
		vec2 probeTex = vec2(mirrorSphereCoord.x, -1.0 * mirrorSphereCoord.y) + vec2(0.5, 0.5);
		return texture2D(probeTexture, probeTex);
	}

	vec4 shadeDiffuse(vec3 worldPos, vec3 worldNormal) {
		vec4 baseColor = vec4(1.0,1.0,1.0,1.0);
		vec3 apparentColor = vec3(0,0,0);
		for (int i = 0; i < 1; i++) {
			vec3 lightDir = lightPos[i].xyz - (worldPos * lightPos[i].w);
			float cos = dot(normalize(worldNormal), normalize(lightDir));
			vec3 M = lightPowerDensity[i] / dot(lightDir,lightDir);
			float spotLight = max(dot(normalize(-1.0 * lightDir),normalize(spotMainDir[i])),0.0);
			apparentColor = apparentColor + max(cos, 0.0) * baseColor.xyz * M * pow(spotLight,5.0);
		}
		return vec4(apparentColor, 1);
	}

	vec4 shadeShiny(vec3 worldPos, vec3 worldNormal) {
		vec4 baseColor = vec4(1.0, 1.0, 1.0, 1.0);
		vec3 apparentColor = vec3(0,0,0);
		for (int i = 0; i < 1; i++) {
			vec3 lightDir = lightPos[i].xyz - (worldPos * lightPos[i].w);
			vec3 h = normalize(lightDir) + normalize(cameraPos - worldPos);
			float cos = dot(normalize(worldNormal), normalize(h));
			float shininess = pow(max(cos, 0.0),5.0);
			vec3 M = lightPowerDensity[i] / dot(lightDir,lightDir);
			float spotLight = max(dot(normalize(-1.0 * lightDir),normalize(spotMainDir[i])),0.0);
			apparentColor = apparentColor + shininess * baseColor.xyz * M * pow(spotLight,5.0);
		}
		return vec4(apparentColor, 1);
	}

	bool findBestHit(vec4 e, vec4 d, out int bestBrdf, out mat4 bestA, out float bestT) {
		bestT = 1000000.0;
		bool foundHit = false;
		for (int i = 0; i < 3; i++) {
			float newT = intersectClippedQuadric(quadrics[2*i], quadrics[2*i+1], e, d);
			if (newT > 0.0 && newT < bestT) {
				bestT = newT;
				bestBrdf = i;
				bestA = quadrics[2*i];
				foundHit = true;
			}
		}
		return foundHit;
	}

	void main(void) {
		vec4 e = vec4(cameraPos, 1.0);
		vec4 d = vec4(rayDir, 0.0);

		int bestBrdf;
		mat4 bestA;
		float bestT;
		if (findBestHit(e, d, bestBrdf, bestA, bestT)) {
			vec4 r = e + d * bestT;
			vec3 normal = normalize((bestA * r + r * bestA).xyz);
			gl_FragColor = shadeShiny(r.xyz, normal);
		} else {
			gl_FragColor = shadeEnvironment();
		}
	}
`;
